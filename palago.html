<!DOCTYPE html>
<html>
<head>

<!-- Bootstrap 3 -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Bootstrap 3 Theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

<!-- Custom Styles -->
<link rel="stylesheet" type="text/css" href="styles.css">

<!-- JQuery 3 -->
<script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>

<!-- Bootstrap 3 Script -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script>
	
	function Neighbors($target) {
		let $column = $target.parent();
		let $columnPrev = $column.prev();
		let $columnNext = $column.next();
		let offset = $column.hasClass("offset");
		let currentIndex = $target.index();
		
		let $columnChildren = $column.children();
		
		var neighbors = new Array();
		
		let indexOffset = (offset? 0 : -1);
		
		
		if (currentIndex - 1 >= 0) neighbors.push($columnChildren[currentIndex - 1]);
		else neighbors.push(null);
		
		if ($columnNext.length) {
			let $columnNextChildren = $columnNext.children();
			
			if ($columnNextChildren[currentIndex + indexOffset]) neighbors.push($columnNextChildren[currentIndex + indexOffset]);
			else neighbors.push(null);
			
			if ($columnNextChildren[currentIndex + 1 + indexOffset]) neighbors.push($columnNextChildren[currentIndex + 1 + indexOffset]);
			else neighbors.push(null);
			
		} else {
			neighbors.push(null);
			neighbors.push(null);
		}
		
		if (currentIndex + 1 < $columnChildren.length) neighbors.push($columnChildren[currentIndex + 1]);
		else neighbors.push(null);
		
		if ($columnPrev.length) {
			let $columnPrevChildren = $columnPrev.children();
			
			if ($columnPrevChildren[currentIndex + 1 + indexOffset]) neighbors.push($columnPrevChildren[currentIndex + 1 + indexOffset]);
			else neighbors.push(null);
			
			if ($columnPrevChildren[currentIndex + indexOffset]) neighbors.push($columnPrevChildren[currentIndex + indexOffset]);
			else neighbors.push(null);
			
		} else {
			neighbors.push(null);
			neighbors.push(null);
		}
		
		return neighbors;
	}
	
	function IsValidPlayerPieceVertex(player, $piece, vertex) {
		if (!($piece instanceof jQuery)) return false;
		if (["L", "R"].indexOf(player) < 0) return false;
		if (vertex < 0 && vertex > 2) return false;
		return true;
	}
	
	function GetPlayerPieceVertex(player, $piece, vertex) {
		if (!IsValidPlayerPieceVertex(player, $piece, vertex)) return false;
		return $piece.data(player)[vertex];
	}
	
	function SetPlayerPieceVertexValue(player, $piece, vertex, value) {
		if (!IsValidPlayerPieceVertex(player, $piece, vertex)) return false;
		return $piece.data(player)[vertex] = value;
	}
	
	function GetPlayerPieceVertexInflow(playerID, $piece, vertexID) {
		if (!IsValidPlayerPieceVertex(playerID, $piece, vertexID)) return false;
		return $piece.data(playerID + "-inflow")[vertexID];
	}
	
	function SetPlayerPieceVertexInflow(playerID, $piece, vertexID) {
		if (!IsValidPlayerPieceVertex(playerID, $piece, vertexID)) return false;
		return $piece.data(playerID + "-inflow")[vertexID] = true;
	}
	
	function MakeNode($piece, playerID, nodeID) {
		return {targetPiece: $piece, targetPlayerID: playerID, targetNodeID: nodeID};
	}
	
	function GetLinkedNode(node) {
		return GetPlayerPieceVertex(node.targetPlayerID, node.targetPiece, node.targetNodeID);
	}
	
	function HasCircuit(node) {
		var visited = new Array();
		
		for (var aNode = node; aNode; aNode = GetLinkedNode(aNode)) {
			if (visited.indexOf(aNode) >= 0) {
				for (var k in visited) console.log(visited[k]);
				return true;
			}
			visited.push(aNode);
		}
		
		return false
	}
	
	function IsClosed($target) {
		for (var i in $target.data("L")) {
			let node = $target.data("L")[i]; 
			if (!node) continue;
			if (HasCircuit(node)) return true;
		}
		
		for (var i in $target.data("R")) {
			let node = $target.data("R")[i];
			if (!node) continue;
			if (HasCircuit(node)) return true;
		}
		
		return false;
	}
	
	function VertexForSide($piece, side) {
		let rotation = $piece.data("rotation") > 0? (3 / (360 / Math.abs($piece.data("rotation")))) : 0;
		//let rotation = $piece.data("rotation") == 0? 0 : ($piece.data("rotation") == 120? 1 : 2);
		let map = [[[0, 1], [2, 5], [3, 4]], [[2, 3], [1, 4], [0, 5]], [[4, 5], [0, 3], [1, 2]]][rotation];
		
		for (var i = 0; i < map.length; i++) {
			if (map[i].indexOf(side) >= 0) return i;
		}
	}
	
	$(function() {
		let $controls = $($("#t-controls").html());
		var $pieceLastCommitted = null;
		var $pieceLastSelected = null;
		
		function $MakeItem() {
			var $item = $("<li>").click(function() {
				if ($pieceLastSelected && !$pieceLastSelected.data("committed"))
					$pieceLastSelected.removeClass("used");
				
				if ($(this).data("committed")) return;
				$(this).data("committed", false)
				
				$pieceLastSelected = $(this);
				
				$controls.css("transform", "rotate(" + ($(this).data("rotation")? ($(this).data("rotation") * -1) : 0) + "deg)");
				$(this).addClass("used").append($controls);
				

				$controls.show();
			});
			
			$item.data("L", [null, null, null]).data("R", [null, null, null]);
			$item.data("L-inflow", [false,false,false]).data("R-inflow", [false,false,false]);
			$item.data("rotation", 0);
			
			return $item;
		}
		
		$controls.find("a.rotation").click(function() {
			let $parent = $(this).closest("li");
			let currentRotation = $parent.data("rotation") || 0;
			let offsetRotation = 120;//($(this).html() == "&gt;")? 120 : -120;
			let rotation = currentRotation + offsetRotation % 360;
			//(offsetRotation < 0 && currentRotation > 0)? currentRotation + offsetRotation : 360 + offsetRotation;
			$parent.css("transform", "rotate(" + rotation + "deg)");
			$parent.data("rotation", rotation);
			$parent.children().each(function(i, child) {
				$(child).css("transform", "rotate(" + (-1 * $parent.data("rotation")) + "deg)")
			});
		})
		
		$controls.find("a.commit").click(function() {
			let $target = $(this).closest("li");
			let $parent = $target.parent();
			let neighbors = Neighbors($target);
			
			//if ($pieceLastCommitted && neighbors.indexOf($pieceLastCommitted[0]) == -1) return;
			
			$pieceLastCommitted = $target;
			
			$target.data("committed", true);
			
			if ($("body > div#board > ul:first-child").is($parent)) {
				var $list = $("<ul>");
				if (!$parent.hasClass("offset")) $list.addClass("offset");
				$parent.children().each(function(i) {
					$list.append($MakeItem());
				})
				$("body > div#board").prepend($list);
			}
			if ($("body > div#board > ul:last-child").is($parent)) {
				var $list = $("<ul>");
				if (!$parent.hasClass("offset")) $list.addClass("offset");
				$parent.children().each(function(i) {
					$list.append($MakeItem());
				})
				$("body > div#board").append($list);
			}
			if ($($parent.children().first()).is($target)) {
				$("body > div#board > ul").each(function(i) {
					$(this).prepend($MakeItem());
				});
			}
			if ($($parent.children().last()).is($target)) {
				$("body > div#board > ul").each(function(i) {
					$(this).append($MakeItem());
				});
			}
			
			var date = new Date();
			console.log(date.getTime());
			
			// Attach line between neighboring tiles
			for (var sideA = 0; sideA < neighbors.length; sideA++) {
				let $neighbor = neighbors[sideA] && $(neighbors[sideA]);
				if (!$neighbor || !$neighbor.hasClass("used")) continue;
				
				let sideB = (sideA + 3) % 6;
				let sideAVertexID = VertexForSide($target, sideA);
				let sideBVertexID = VertexForSide($neighbor, sideB);
				
				// Check if there's a line on the neighbor to anything, if not, attach one to this one.
				// If neighbor has a line to something else, attach a line from here to neighbor instead.
				let PlayerIDs = ["L", "R"];
				for (var k in PlayerIDs) {
					let playerID = PlayerIDs[k];
					if ((GetPlayerPieceVertexInflow(playerID, $neighbor, sideBVertexID) && !GetPlayerPieceVertex(playerID, $neighbor, sideBVertexID)) || GetPlayerPieceVertex(playerID, $target, sideAVertexID)) {
						SetPlayerPieceVertexValue(playerID, $neighbor, sideBVertexID, MakeNode($target, playerID, sideAVertexID));
						SetPlayerPieceVertexInflow(playerID, $target, sideAVertexID);
						console.log("Connection from neighbor [" + playerID + " - " + ["A", "B", "C"][sideBVertexID] + "] to target [" + playerID + " - " + ["A", "B", "C"][sideAVertexID] + "]:");
						console.log($neighbor)
						console.log($target);
					} else {
						SetPlayerPieceVertexValue(playerID, $target, sideAVertexID, MakeNode($neighbor, playerID, sideBVertexID));
						SetPlayerPieceVertexInflow(playerID, $neighbor, sideBVertexID);
						console.log("Connection from target [" + playerID + " - " + ["A", "B", "C"][sideAVertexID] + "] to neighbor [" + playerID + " - " + ["A", "B", "C"][sideBVertexID] + "]:");
						console.log($target)
						console.log($neighbor);
					}
				}
			}
			
			if (IsClosed($target)) console.log("Loop detected!");
			
			$controls.hide();
		})

		var $StartList = $("<ul>").append($MakeItem());
		$("body > div#board").append($StartList);
	});
	
</script>

</head>
	<body>
		<!-- Navigation Bar -->
		<nav class="navbar navbar-inverse navbar-static-top">
			<div class="container-fluid">

				<!-- The header below will only be visible on mobile -->
				<header class="navbar-header">
					<a class="navbar-brand" href="palago.html">
						<span>Palago</span>
					</a>
					<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-primary">
						<!-- "Toggle navigation" only visible on screen-readers -->
						<span class="sr-only">Toggle navigation</span>

						<!-- The spans below comprise the [mobile's] menu button three horizontal bars -->
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</button>
				</header>

				<!-- Navigation links and other content will be collapsable when in mobile devices -->
				<div class="collapse navbar-collapse" id="navbar-primary">
					
					<!-- Left navigation bar segment -->
					<div class="navbar-left">
						<ul class="nav navbar-nav">
							<li>
								<a href="help.html">Help</a>
							</li>
							<li>
								<a href="about.html">About</a>
							</li>
						</ul>
					</div>

					<!-- Right navigation bar segment -->
					<div class="navbar-right">
						<p class="navbar-text" data-toggle="tooltip" data-placement="top">[ALPHA]</p>
					</div>
				</div>
			</div>
		</nav>

		<template id="t-controls">
			<div>
				<p><a href="#" class="rotation">TURN</a></p>
				<p><a href="#" class="commit">[PLACE]</a></p>
			</div>
		</template>
		<div id="board"></div>
	</body>
</html>
